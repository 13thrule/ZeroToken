"""
assembler.py — Final Agent Prompt builder.

Combines the plan + all approved step diffs into ONE BIG PROMPT that you
copy/paste into Claude (or any agent).  Claude is the executor — it reads
this prompt and applies the changes to the repo.

ZeroToken does all the thinking (planning, patching, refining, reviewing).
Claude just runs what ZeroToken has already decided.
"""

import os

# ---------------------------------------------------------------------------
# Template sections
# ---------------------------------------------------------------------------

_HEADER = """\
# ╔══════════════════════════════════════════════════════════════════╗
# ║             ZEROTOKEN — FINAL AGENT EXECUTION PROMPT            ║
# ║        Generated by: ZeroToken · local multi-agent system       ║
# ╚══════════════════════════════════════════════════════════════════╝

You are a coding agent. Your job is to apply a set of pre-planned,
pre-reviewed changes to a software project.

ZeroToken has already:
  ✔ Generated the plan (Ollama-Planner)
  ✔ Generated the patches (Ollama-Patcher)
  ✔ Reviewed each patch (Ollama-Reviewer — local sanity check)
  ✔ Refined each patch (Ollama-Refiner — best-effort improvement)

Your primary job is to apply these diffs. However, if a diff fails to apply
cleanly or contains obvious bugs, fix it intelligently rather than failing.
You have full context — use your judgment.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
PROJECT: {project_name}
ROOT:    {root}
GOAL:    {goal}
STACK:   {arch_summary}
STEPS:   {n_approved} to apply{n_skipped_note}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

"""

_STEP_TEMPLATE = """\
┌─────────────────────────────────────────────────────────────────────
│ STEP {id} of {total}: {title}
│ Files : {files}
│ Source: {source}
│ Status: APPROVED — apply this diff
└─────────────────────────────────────────────────────────────────────
{description}
│ Acceptance criteria:
{criteria_lines}
```diff
{diff}
```

"""

_FOOTER = """\
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
EXECUTION RULES
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. Apply diffs in order — do NOT reorder or skip approved steps.
2. Each diff is a standard unified diff (--- a/ +++ b/ @@ format).
3. If a diff fails to apply cleanly or has obvious errors:
   - Read the CURRENT file contents
   - Understand what the diff intended from the description + criteria
   - Apply the change manually to achieve the same result
   - Do NOT abort the whole run for one conflict
4. After all steps are applied, run any relevant tests.
5. Read back EACH modified file after applying its diff. Confirm:
   - The intended change is present
   - No syntax errors were introduced
   - The acceptance criteria for that step are satisfied
6. After ALL steps, report clearly:
   - Which steps applied cleanly
   - Which needed manual fixes and exactly what you changed
   - Whether each step's acceptance criteria are satisfied
   - Any tests run and their results

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
VALIDATION CHECKLIST (verify AFTER applying all steps)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
{validation_checklist}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
END OF ZEROTOKEN AGENT PROMPT
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
"""


# ---------------------------------------------------------------------------
# Public API
# ---------------------------------------------------------------------------

def assemble_final_prompt(goal: str, plan: dict, diffs: dict, root: str = ".") -> str:
    """
    Build the final agent prompt from all approved step diffs.

    Args:
        goal  : The project goal string
        plan  : Full plan dict with a 'steps' list
        diffs : step_id -> diff_text  (only approved steps — caller decides which)
        root  : Absolute path to the project root

    Returns:
        The complete agent prompt as a single string ready to paste into Claude.
    """
    import pathlib

    root_path = pathlib.Path(root).resolve()
    project_name = root_path.name

    # Best-effort architecture summary (non-fatal if unavailable)
    try:
        from ai_build.context import detect_stack
        arch_summary = detect_stack(str(root_path))
    except Exception:
        arch_summary = "unknown"

    steps = plan.get("steps", [])
    approved_steps = [s for s in steps if s["id"] in diffs]
    skipped_steps  = [s for s in steps if s.get("status") == "skipped"]

    n_skipped_note = (
        f", {len(skipped_steps)} skipped" if skipped_steps else ""
    )

    header = _HEADER.format(
        project_name  = project_name,
        root          = str(root_path),
        goal          = goal,
        arch_summary  = arch_summary,
        n_approved    = len(approved_steps),
        n_skipped_note= n_skipped_note,
    )

    body_parts: list[str] = []
    checklist_lines: list[str] = []

    for step in approved_steps:
        sid   = step["id"]
        diff  = diffs[sid]
        files = ", ".join(step.get("suggested_files", [])) or "(unspecified)"
        desc  = step.get("description", "").strip()

        # Acceptance criteria — inline in step block
        criteria = step.get("acceptance_criteria", [])
        if criteria:
            criteria_lines = "\n".join(f"│   • {c}" for c in criteria)
        else:
            criteria_lines = "│   (none specified)"

        # Source tracking — helps Claude calibrate trust
        source = step.get("_source", "Ollama-local (auto-generated)")

        body_parts.append(_STEP_TEMPLATE.format(
            id             = sid,
            total          = len(approved_steps),
            title          = step.get("title", f"Step {sid}"),
            files          = files,
            source         = source,
            description    = desc,
            criteria_lines = criteria_lines,
            diff           = diff.strip(),
        ))

        # Build validation checklist entry for footer
        for c in criteria:
            checklist_lines.append(f"  Step {sid}: {c}")
        if not criteria:
            checklist_lines.append(f"  Step {sid}: (no criteria — verify description was implemented)")

    # Note skipped steps
    if skipped_steps:
        skip_lines = "\n".join(
            f"  - Step {s['id']}: {s.get('title', '')}" for s in skipped_steps
        )
        body_parts.append(
            f"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
            f"SKIPPED STEPS (do not apply)\n"
            f"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
            f"{skip_lines}\n\n"
        )

    validation_checklist = "\n".join(checklist_lines) if checklist_lines else "  (no criteria specified)"

    footer = _FOOTER.format(validation_checklist=validation_checklist)

    return header + "".join(body_parts) + footer
